import { ComputedGetter, WritableComputedOptions } from "../../reactivity/computed.js";
import { DebuggerHook } from "./apiLifecycle.js";
import { Component, ComponentInternalInstance, ConcreteComponent, Data } from "./component.js";
import { EmitsOptions } from "./componentEmits.js";
import { SlotsType } from "./componentSlots.js";
import { Directive } from "./directives.js";

export type ComputedOptions = Record<
  string,
  ComputedGetter<any> | WritableComputedOptions<any>
>

export type MergedComponentOptions = ComponentOptions &
  MergedComponentOptionsOverride
type MergedHook<T = () => void> = T | T[]

export type MergedComponentOptionsOverride = {
  beforeCreate?: MergedHook
  created?: MergedHook
  beforeMount?: MergedHook
  mounted?: MergedHook
  beforeUpdate?: MergedHook
  updated?: MergedHook
  activated?: MergedHook
  deactivated?: MergedHook
  /** @deprecated use `beforeUnmount` instead */
  beforeDestroy?: MergedHook
  beforeUnmount?: MergedHook
  /** @deprecated use `unmounted` instead */
  destroyed?: MergedHook
  unmounted?: MergedHook
  renderTracked?: MergedHook<DebuggerHook>
  renderTriggered?: MergedHook<DebuggerHook>
  // errorCaptured?: MergedHook<ErrorCapturedHook>
}

export interface MethodOptions {
  [key: string]: Function
}

type ObjectInjectOptions = Record<
  string | symbol,
  string | symbol | { from?: string | symbol; default?: unknown }
>
type ObjectProvideOptions = Record<string | symbol, unknown>

export type ComponentInjectOptions = string[] | ObjectInjectOptions

export type ComponentProvideOptions = ObjectProvideOptions | Function

// export interface ComponentOptionsBase<
//   Props,
//   RawBindings,
//   D,
//   C extends ComputedOptions,
//   M extends MethodOptions,
//   Mixin extends ComponentOptionsMixin,
//   Extends extends ComponentOptionsMixin,
//   E extends EmitsOptions,
//   EE extends string = string,
//   Defaults = {},
//   I extends ComponentInjectOptions = {},
//   II extends string = string,
//   S extends SlotsType = {},
//   LC extends Record<string, Component> = {},
//   Directives extends Record<string, Directive> = {},
//   Exposed extends string = string,
//   Provide extends ComponentProvideOptions = ComponentProvideOptions,
// > extends LegacyOptions<Props, D, C, M, Mixin, Extends, I, II, Provide>,
//   ComponentInternalOptions,
//   ComponentCustomOptions {
//   setup?: (
//     this: void,
//     props: LooseRequired<
//       Props &
//       Prettify<
//         UnwrapMixinsType<
//           IntersectionMixin<Mixin> & IntersectionMixin<Extends>,
//           'P'
//         >
//       >
//     >,
//     ctx: SetupContext<E, S>,
//   ) => Promise<RawBindings> | RawBindings | RenderFunction | void
//   name?: string
//   template?: string | object // can be a direct DOM node
//   // Note: we are intentionally using the signature-less `Function` type here
//   // since any type with signature will cause the whole inference to fail when
//   // the return expression contains reference to `this`.
//   // Luckily `render()` doesn't need any arguments nor does it care about return
//   // type.
//   render?: Function
//   // NOTE: extending both LC and Record<string, Component> allows objects to be forced
//   // to be of type Component, while still inferring LC generic
//   components?: LC & Record<string, Component>
//   // NOTE: extending both Directives and Record<string, Directive> allows objects to be forced
//   // to be of type Directive, while still inferring Directives generic
//   directives?: Directives & Record<string, Directive>
//   inheritAttrs?: boolean
//   emits?: (E | EE[]) & ThisType<void>
//   slots?: S
//   expose?: Exposed[]
//   serverPrefetch?(): void | Promise<any>

//   // Runtime compiler only -----------------------------------------------------
//   compilerOptions?: RuntimeCompilerOptions

//   // Internal ------------------------------------------------------------------

//   /**
//    * SSR only. This is produced by compiler-ssr and attached in compiler-sfc
//    * not user facing, so the typing is lax and for test only.
//    * @internal
//    */
//   ssrRender?: (
//     ctx: any,
//     push: (item: any) => void,
//     parentInstance: ComponentInternalInstance,
//     attrs: Data | undefined,
//     // for compiler-optimized bindings
//     $props: ComponentInternalInstance['props'],
//     $setup: ComponentInternalInstance['setupState'],
//     $data: ComponentInternalInstance['data'],
//     $options: ComponentInternalInstance['ctx'],
//   ) => void

//   /**
//    * Only generated by compiler-sfc to mark a ssr render function inlined and
//    * returned from setup()
//    * @internal
//    */
//   __ssrInlineRender?: boolean

//   /**
//    * marker for AsyncComponentWrapper
//    * @internal
//    */
//   __asyncLoader?: () => Promise<ConcreteComponent>
//   /**
//    * the inner component resolved by the AsyncComponentWrapper
//    * @internal
//    */
//   __asyncResolved?: ConcreteComponent
//   /**
//    * Exposed for lazy hydration
//    * @internal
//    */
//   __asyncHydrate?: (
//     el: Element,
//     instance: ComponentInternalInstance,
//     hydrate: () => void,
//   ) => void

//   // Type differentiators ------------------------------------------------------

//   // Note these are internal but need to be exposed in d.ts for type inference
//   // to work!

//   // type-only differentiator to separate OptionWithoutProps from a constructor
//   // type returned by defineComponent() or FunctionalComponent
//   call?: (this: unknown, ...args: unknown[]) => never
//   // type-only differentiators for built-in Vnode types
//   __isFragment?: never
//   __isTeleport?: never
//   __isSuspense?: never

//   __defaults?: Defaults
// }
export interface ComponentOptionsBase<> {}

export type ComponentOptionsMixin = any

export type ComponentOptions<
  Props = {},
  RawBindings = any,
  D = any,
  C extends ComputedOptions = any,
  M extends MethodOptions = any,
  Mixin extends ComponentOptionsMixin = any,
  Extends extends ComponentOptionsMixin = any,
  E extends EmitsOptions = any,
  EE extends string = string,
  Defaults = {},
  I extends ComponentInjectOptions = {},
  II extends string = string,
  S extends SlotsType = {},
  LC extends Record<string, Component> = {},
  Directives extends Record<string, Directive> = {},
  Exposed extends string = string,
  Provide extends ComponentProvideOptions = ComponentProvideOptions,
> = any